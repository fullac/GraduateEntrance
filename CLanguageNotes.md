# C
> 考纲是会呼吸的痛，没有考纲是窒息的痛。

## 说在前面
刷题中C和C++的题混合在一起，下文的知识点也是杂糅的，请注意！C++已标注出。

## I Grammar 
1. `struct`存在字节对齐。
2. main函数是程序的入口，也是程序的出口。程序从main函数开始，到main函数结束。
3. 连续的逻辑运算在逻辑上是错误的，但是编译上是没问题的。例如`x = 'A'; '0' <= x <= '9';`等价于`('0' <= x) <= '9';`结果为`true`。
4. C允许赋值使用连等，声明不允许连等。即`int a = b = 1;`是错的，但是`a = b = 1;`是对的。
5. **格式输入**：
   - 类型控制：
      - c：读入单个字符（后面不会加上空字节）；
      - s：读入一个的字符序列，后面会加上空字节，遇到空白字符(\t \r \n 空格等)完成读取；
      - d：读入可选有符号十进制整数；
      - u：读入无符号符号十进制整数；
      - i：读入可选有符号整数；
      - a,e,f,g,A,E,F,G：读入可选有符号浮点数；
      - o：读入可选有符号八进制整数；
      - x,X：读入可选有符号十六进制整数；
      - p：读入一个指针值（16进制）；
      - n：不读入任何字符，而是把到该位置已读入的字符数存储到与之对应的int*指向的位置。
   - 长度控制：
      - l：长（例如`%lf`为双精度浮点double）；
      - h：短。
   -  *符：跳过该输入值（例如`scanf("%d %*d %d",&a,&b);`b得到的是第三个`%d`的值。
   -  宽度控制：
        - 和格式输出一样；
        - 数据切分：`scanf("%4d%4d",&a,&b);`输入12345678将把1234赋予a，而把5678赋予b。
   - scanf没有精度控制。
6. 科学计数的字面常量：12e34，e后面必须为整数。
7. 字面常量后缀：l表示长整数，u表示无符号整数，不区分大小写和顺序。
8. **格式输出**：  
   - string的格式化输出：`%m.ns`表示长度为n~m的字符串。
   - data格式化输出：`%md`以宽度m右对齐输出data，宽度小于实际时，按实际输出，不足补空格；`%0md`补0，其他同前者；
   - float的格式化输出：`%m.nf`以宽度m输出保留n位小数，宽度小于实际时，整数部分按实际输出，但小数需要四舍五入至n位。
      > 例如123.456按`%1.1f`输出的结果是123.5
9. **二维数组的指针：对于`int a[5][5];`，其名字a本质上是标识符，在C语言中数组名退化为指向数组元素的指针**
   - `a`是指针，值为二维数组的起始地址，`*a`对`a`解引用得到第一行的起始地址，他们指向的地址相同，但指向的值不同（一个是二维数组，一个是一维数组）；
     > 因为<mark>数组指针退化，`a`指向了第一行（一维整型数组），`*a`指向了第一行的第一个元素（整型元素）</mark>。
   - `a[0]`是指针，值为第一行的起始地址，解引用指向它的指针的写法为`*a`，另外`a[0]`与`*a`是等价的；
   - `a[0][0]`是值，为第一个元素的值，解引用指向它的指针的写法为`**a`或`*a[0]`。
   - 数组的指针退化：
     - 名称为一维数组名的指针，退化成指向元素（仅向下一维）的指针，对其做加一操作将偏移一个元素的距离而非数组长度的距离，但是取址后加一偏移数组长度的距离，见题2；
     - 该指针为指针常量，不可修改（指向不可改变），自增是不合法的；
     - 当函数参数声明使用数组时依然会存在指针退化，例如`int fun(int* p[4])`等价为`int fun(int** p)`。
   - 可以用取址代替解引用，例如`a[1][2] == *(*(a + 1) + 2) == *(&a[1][1] + 1) == *(a[1] + 2)`。
10. `extern "C"`修饰的函数会被编译器强制按照C语言的方式进行编译。
11. 顺序求值运算符`,`，逗号表达式的值等于最后一个表达式的结果，且赋值运算符优先级大于顺序求值运算符。
12. 关于ASCII与ANSI：ASCII是ANSI的子集。
   - 标准的ASCII占7bit，扩展的ASCII占8bit；
   - ASCII含有关于控制的字符，不可打印。
11. 字符常量：普通字符`'A'`与转义字符`'\101'`或`'\0101'`或`'\x41'`，转义字符只能用八进制或十六进制。特别的，反斜杠的转义字符为`\\`。
12. 宽字符常量与宽字符串常量：`L'a', L"aaaaa"`。
13. **C语言不支持运算符重载**。C++支持重载，但三目运算符`?:`、作用域运算符`::`、成员指针运算符`.*`与`->*`、`.`、`sizeof`不可重载。
14. <mark>结构体中不允许直接定义本结构体类型的变量，但可以定义指向本结构体类型的指针。</mark>
15. <mark>从C源代码到可执行文件的四个过程：预处理、编译、汇编、链接：Linux下每个过程对应的生成文件扩展名为：.c -> .i -> .s -> .o -> .exe</mark>
16. C的函数省略类型默认为int，且与返回类型不一致时，均以函数类型为准。
17. <mark>**`static`关键字的作用**：</mark>
    - 静态局部变量：仅初始化一次，即使无值也会默认填0；另外改变变量的存储位置（栈区->静态区），延长生命周期；
    - 静态全局变量：仅当前文件可访问，外部文件即便使用`extern`也无法访问；
    - 静态函数：仅当前文件可访问；
    - 静态成员变量与成员函数：可以通过对象或者类名访问静态成员函数；
    - <mark>出现在类体外的函数定义不能指定关键字`static`”：在外部定义成员函数时不能使用`static`，因为成员函数作用域为类域，在外使用`static`会改变为文件域，从而报错。</mark>
18. 函数原型： `returntype funcname(paratype paraname);`，其中返回类型和参数名可省略。
19. 指针声明后未初始化，其值是随机的，也是野指针。除此以外，指针越界访问与指针指向的空间被释放，也会导致野指针。
20. 三目运算符结合性从右到左。
21. 文件读写模式：均用双引号包裹
    - r读文件，w清空写，a追加写，+表示扩充；
    - b表示二进制文件，t表示text；
    - r和r+文件必须存在，否则返回打开失败；
    - w和w+在文件存在时**清空文件**再写（而不是从头覆盖写）；
    - a和a+再文件末尾追加写。
    > w为清空写，a为追加写
22. 赋值与复合赋值的区别：
    - 从计算机来看是等效的；
    - 从内存看复合赋值不会使用临时变量，而是直接将结果赋值，赋值语句将右边算术结果存于临时变量，再赋值给左边。
23. 对于指针变量p，`p = NULL;`等价于`p = 0;`。
24. 装入时静态分配内存，运行时动态分配内存。
25. 指针可以进行比较大小、赋值、减法，但不能进行加法。减法运算的意义是丘两个地址的距离，而加法是没有意义的。
26. C语言程序能够在不同的操作系统下运行，这说明C语言具有很好的移植性。（硬件兼容，软件移植）
27. '\0'的值为0，在内存中的存储值为00000000，它是ASCII的第一个字符（控制字符）。
28. C语言中数据类型长度：
   - `32bit: bool/char/uchar 1B, short/ushort 2B, double/ll 8B, else(include pointer) 4B`
   - `64bit: bool/char/uchar 1B, short/ushort 2B, long/ulong/double/ll/pointer 8B, else 4B`
29. IEEE754标准下float浮点类型的格式: 1bit符号位，8bit阶码位，23bit尾数位。阶码真值取值范围为-126~127，即阶码数值-偏置值127。
30. for循环和while循环一样，一旦判断为否就会结束。
31. 关于**运算符优先级和结合顺序**：
   - <mark>选择（左到右） > 单目（右到左） > 双目（除三目赋值左到右）（乘除模 > 加减 > 移位 > 关系 > 按位 > 逻辑 > 三目 > 赋值相关 > 逗号）</mark>
   - `-负号, ~按位取反, ++自增, --自减, *取值, &取址, !逻辑非, (typename)强制类型转换, sizeof()长度运算符`的优先级大于乘、除、模；
   - <mark>以上运算符、`?:`三目运算符以及`=, *=, ^= ···`赋值相关运算符的结合顺序均为：从右至左。</back>其余为从左至右；
      > 例如：`int a[3] = {1, 10, 100}; int *p = a;`
      >  - `*p++`先自增，再解引用。但由于后置++先完成运算，再改变值，所以实际上解引用的结果是`*p = 1`，该行运算结束后，p自增，即指向了下一元素10；
      >  - `(*p)++`先解引用，再自增。解引用的结果为`*p = 1`，但是运算完成后，原地址上的值进行了自增，即`int a[3] = {2, 10, 100};`；
      >  - `*++p`先自增，再解引用。`*p = 10`；
      >  - `++*p`先解引用，再自增。`*p = 2`。
   - `[]数组下标, ()括号, .成员选择, ->箭头`的运算级别最高。
32. 在C语言中，函数的递归可以嵌套，**但是定义不可嵌套。**
33. heap的push和pop操作：
    - push：将元素插入堆尾，然后自底向上调整；
    - pop：将堆首（根）删除，再将堆尾替换堆手，然后自顶向下调整。
34. 建堆：
    - 若对完整序列直接建堆：先按层次遍历构建完全树，再调整为堆；
    - 若依次插入数据，则每次插入后都需要调整为堆。
35. 值类型和引用类型的空间：忽略，此为C#的概念。
36. **正则表达式：** 算了，反正也记不住。
37. 标识符、预定义标识符以及关键字：。
    - 标识符：非数字开始的一个由字母、数字、下划线组成的字符串；
    - 预定义标识符：系统预先定义的标识符，如系统函数名，系统常量名；
    - 关键字：具有特殊含义的词语，共32个，均为小写字母。
38. 无法通过内存释放函数free(void*)直接将某块已经使用完的物理内存直接还给操作系统，因为可能要等到进程结束才能释放。
39. **C语言进程的逻辑地址分区：**
    - 栈区：存放函数形参、返回值以及局部变量，包括指针；
    - 堆区：此区域需要程序员手动释放，否则可能由OS在程序结束时释放；
    - 全局（静态）区：包括全局变量、静态（全局/局部）变量，已初始化存放于`.data`，未初始化存放于`.bass(Block Started by Symbol)`；
    - 文字常量区`.rodata`：例如"abc"，以及常变量；
      > 这些常量是不可修改的，例如`char *str1 = "hello"; char *str2 = str1; char str3[] = "hello";`，尝试修改str1是非法的，而修改str2和str3是可行的。
      > `char *str1 = "hello";`将字面量赋值给字符指针，实际上指针存储的是字面量的首地址。C语言中，字符串字面量通常存储在文字常量区，不可修改。
      > `char str3[] = "hello";`定义一个字符数组，数组的内容为`['h', 'e', 'l', 'l', 'o', '\0']`，是C风格的字符串。
    - 代码区`.text`。
40. **可执行程序的三段：**
    - `.bss`：未初始化；
    - `.data`：已初始化以及常量；
    - `.text`：代码。
41. 空结构体的大小为0字节（用编译器试过），但是sbGPT说C语言空结构体会报错或是大小为1字节。
42. 什么是字符串比较大小：比较的是每位的ASCII码值大小。
43. 常量指针：`const int* p;`or`int const* p;`
44. 指针常量：`int *const p;`
45. C语言结构体中不允许有函数，但是C++允许
46. **枚举类**：枚举类定义一组离散常量，
   ```c
      enum color{
         red, // 枚举类默认从0开始
         yellow, // 默认每一项为前一项+1
         blue = 0, // 自定义，枚举类型元素的值可以是整型，无符号整型，字符，布尔（_Bool，C99后定义于stdbool.h）无符号字符。浮点报错。（目前只试过这些）
         green = 10, // 自定义，不再依赖前项+1
         black, // 未定义，前一项+1
      };
      enum color color1; // 枚举可以直接使用，不需要再次声明，且枚举被视为整型或无符号整型，color1未初始化的值是未定义的。给color1赋其他整数是可行的。
   ```
47. 文件IO：不一定要明确使用fopen打开（三流会自动打开），但要明确使用fclose关闭文件（程序中不使用fclose关闭文件本身不会报错，会留给OS关闭文件，但这可能造成不可预知问题，所以原则上是要在结束时明确使用fclose关闭文件）。
48. C语言的赋值语句的返回值为：赋值符号右边的值。即`int a = 1, b; b = (a = 100);`的结果是`b = 100`。
49. 函数隐含的存储类型为`extern`。
50. 数组声明：
   - 二维数组必须至少写明列数，若一行元素不足会自动补0，如`int a[3][] = {{1}, {2}, {3]};`，其中`a = {{1, 0, 0}, {2, 0, 0}, {3, 0, 0}}`。
51. 当char类型声明的字符不符合单一字符规则，从右往左取值。
> 例如`char c = '\xff\123\876abc123';`，`'\xff'`十六进制转义，`'\123'`八进制转义，`'\876'`非转义，不符合单字符的规则，赋值给char实际是读的最右侧字符。
> 特别地，`'\'`报错，因为`\'`是单引号转义，会报字符单引号缺失的错误，`'\8'`非八进制，赋值给char实际为`'8'`，`'\87'`非八进制，赋值给char实际为`'7'`，`'\876'`非八进制，赋值给char实际为`'6'`。
52. C语言浮点数
   - 不满足位运算，未必满足加法和乘法交换律（因为可能不使用IEEE754标准），一定不满足结合律；
   - 浮点数比大小，由于浮点数存在误差，直接比较大小往往不是预期的结果；通常引入一个比要求精度还要小几个数量级的实数epsilon来帮助比较大小，epsilon的取值会影响到比较的结果。
53. 关于共用体union、结构体struct、位域：
   - 共用体中不能使用位域；
   - 共用体内元素首地址是相同的；
   - 共用体不可直接赋值，也不可像结构体这样初始化；
     >
      ```
         union Union{
            int a;
            double b;
            char c;
         }u;
         u = 10; // 错误，不可直接赋值
         u = {1, 1.2, 'a'}; //错误，不可这样初始化
         u.a = 266; // 此时，a的二进制位0b100001010，对应的char只截第一个最低字节（按小端为00001010），所以u.c对应的整数为10；
      ```
   - 位域仅限于`int`、`unsigned int`、`signed int`三种类型；

## II Function&Macro&System Call
### <mark>**<stdio.h>**</mark>
1. <mark>**fseek函数，seek寻找，目标位置**</mark>：`int fseek( FILE *stream, long offset, int origin );`，功能为移动到文件的某一个位置。
   > 三个参数分别为，文件指针，位移量，起始点。
2. <mark>**rewind函数，rewind倒带，重回开头**</mark>：`void rewind(FILE *filepointer);`，使位置指针重新返回文件的开头。
3. <mark>**ftell函数，tell告知，偏移量**</mark>：`long ftell(FILE *stream);`，得到文件位置指针当前位置相对于文件首的偏移字节数。
4. 文件读写：
   - `fgetc`：读一个字符。成功返回该字符的`unsigned char`强制转换为`int`的结果，并把位置标识符往后移动。失败返回`EOF`。
   - `fgets`：读出字符串。成功返回指针，失败返回`NULL`。
   - `fputc`：写一个字符。成功返回写入的字符，失败返回`EOF`。
   - `fputs`：写入字符串。成功返回非负值，失败返回`EOF`。
5. **scanf函数**：`int scanf(const char * restrict format,...);`，返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。
6. **fprintf函数**：

### <string.h>
1. **strlen函数**：`strlen()`的参数必须是`const char *`，其计算长度的方法是，计算开始至第一个终止符`'\0'`的距离（不含`'\0'`），若没有则结果未知。
   > `sizeof()`是运算符，返回所占内存字节数，因此用`sizeof()`计算C风格字符串时，结果会多计算一个终止符。
2. **strcmp函数**：`int strcmp(const char *str1, const char *str2);`，通过ASCII比较两个字符串的大小
   - 返回0：相等
   - 返回正：str1 > str2
   - 返回负：str1 < str2
3. <mark>**strcat函数，catenate链接，拼接字符串**</mark>：`char *strcat(char *dest, const char *src);`，将后者追加至前者（第一个'\n'前的字符串）末尾。

### <unistd.h>  not std
1. **write函数**：`ssize_t write(int handle, void *buf, int nbyte);`，能够把指定长度的字节序列从缓冲区插入到输出流中。
   
### <stdlib.h>
1. **malloc函数**：`void *malloc(int num);`，**C语言中malloc不需要强制类型转换，从void*到其他类型的指针是自动隐式转换的。**。定义于<stdlib.h>。

### system call
1. **assert宏**：`void assert(int expression);`，断言出错将输出错误信息并终止程序，无返回值。定义于<assert.h>。


## ~~III StandardLibrary~~
1. <assert.h>
   - assert
   - NDEBUG
2. <ctype.h>
3. 




## III Questions
1. 输出结果为`-1`。
  字符型占一字节在赋值0xFFFF时会截断，此时x的值为FF即11111111。
  内存中的数据是带符号补码表示，其原码为10000001，即-1。
  在printf一行，x--先输出再减一。
  ```c
  int main() { 
    char x = 0xFFFF;
    printf("%d\n",x--);
  }
  ```
2. 输出结果为`2， 5`。
  `&a`为数组a的首地址，且数组大小为5int，因此+1时的偏移量为5int，即`&a + 1`表示整个数组之后的下一地址，亦即数组结尾的下一地址。
  而`a + 1`的偏移量为1int，a + 1表示下一个数组元素的地址。
  此题中进行了强制转换`(int*)(&a + 1)`，因此`ptr - 1`的偏移量为1int，因此`ptr - 1`为数组的最后一个元素地址。
  `*(a + 1)`显然为数组的第二个元素。
  ```c
  int main() {
      int a[5]  = {1, 2, 3, 4, 5};
      int *ptr = (int*)(&a + 1);
      printf("%d, %d", *(a + 1), *(ptr - 1));
      return 0;
  }
  ```
3. C++运算符重载：由于C不涉及运算符重载，这里只引用网址。
   - `https://www.nowcoder.com/questionTerminal/be52cbd020be462f8f5a5a1e8b63aca7?`
   - `https://www.nowcoder.com/questionTerminal/aa0807a3e1e641e0b71ce62c08c5e205?`
4. 输入`ABC`，输出结果为`ABC6789`。
     - `gets()`会将输入流中的回车`'\n'`转换为`'\0'`存入`ss`中，此后`ss = 'ABC\0,3,4,5\0'`；
     - `strcat()`会从第一个`'\0'`开始拼接两个字符串，此后`ss = 'ABC6789\0,5\0'`；
     - 输出时读取到第一个`'\0'`就会停止。
   ```C
   #include  “stdio.h"  
   #include  “string.h"  
   int main()  
   {  
       char ss[10]="1,2,3,4,5";
       gets (ss); 
       strcat (ss,"6789"); 
       printf ("%s\n",ss); 
       return 0;
   }
   ```
5. 辨析：
   ```C
   int *p[n];//指针数组
   int (*)p[n];//非法，括号内的*没有关联变量或类型名
   int *p()；//指针函数
   int (*)p();//非法，括号内的*没有关联变量或类型名
   //另外，函数指针的正确写法如下：
   int (*p)();//p指向一个返回类型为int，不接受任何类型的参数。
   ```
6. **关于`fork()`**，`fork()`不是C的库函数，是Linux系统调用。
   该段代码将生成3个子进程，输出6次。
   ```
   P0->P1->P3
     ->P2
   ```
   ```C
   #include <unistd.h>
   #include <stdio.h>
   int main(void) {
       int i = 0;
       for(i = 0; i < 2; i++){
           pid_t fpid = fork();
           if(fpid == 0)
               printf("hello world!\n");
           else
               printf("hello world!\n");
       }
       return 0;
   }
   ```
7. 以下代码存在的问题。
   ```C
   void func1(char *e){
      char *p1;
      p1=malloc(100);//C中可以不用强制类型转换，但其申请的空间在后面没有被释放
      sprintf(p1,error:"%s'.",e);//gpt说此处可能溢出
      local_log(p1);
   }
   int func2(char *filename){
      FILE *fp;
      int key;
      fp=fopen(filename,"r");//打开流在后面未关闭
      fscanf(fp,"%d",&key);
      return key;
   }
   void func3(char *info){
      char *p,*pp;
      p=malloc(100);
      pp=p;
      free(p);
      sprintf(pp,*info:"%s'.",info);
      free(pp);//pp和p所指的空间是一样的，这里free了同一块空间
   }
   ```
8. 以下函数中，和其他函数不属于一类的是fseek。`{ read, pread, write, pwrite, fseek, lseek}` 。只有fseek是库函数，其他都是系统调用
9. “函数中的静态变量,在函数退出后不被释放”，这句话不完全正确，主函数作为程序的入口在退出后会释放静态变量。
10. 如下函数存在的问题：由于值传递，实际上申请到空间的是形参p，而不是实际的p指针，实际的p指针依然为NULL。
    > 如果在C++中可以使用引用传递，即`char* &p`
    ```c
    void getMemory(char *p) {   // (char **p)
       p = (char *)malloc(100); // *p = (char *)malloc(100);
    }
    ```
11. 下列代码输出的是什么：`x=tse,y=`
   ```c
   #include<stdio.h>
   #include<string.h>
   int main(void){
   int n;
   char y[10] = "ntse";// char型数组y，前五个元素分别为'n','t','s','e','\0'
   char *x = y;// char型指针，指向y的第一个元素的地址
   n = strlen(x);// strlen（refer to Function&System Call.2）的算法是直到找到第一个'\0'才停止寻找，必须传入char*类型的参数，因此这里得到的n = 4
   *x = x[n];// 将x[4]赋值给x的解引用，即将y[4]赋值给y[0]，y[] = {'\0','t','s','e','\0'}
   x++;// x变为指向y[1]的指针
   printf("x=%s,", x);// printf遇到第一个'\0'即停止，因此x输出为tse
   printf("y=%s\n", y);// printf遇到第一个'\0'即停止，因此y输出为空
   return 0;
   }
   ```
12. 下文程序在下x86机器上运行的结果：50
    > 请注意在x86机器上一般为**小端存储的4字节对齐**
   ```c
   struct mybitfields
   {
       unsigned short a : 4;//位域
       unsigned short b : 5;
       unsigned short c : 7;
   } test //test的存储空间为[----,-----,-------]
   void main(void)
   {
       int i;
       test.a = 2; //a = 0b0010, test = [0100,-----,-------]
       test.b = 3; //b = 0b00011, test = [0100,11000,-------]
       test.c = 0; //c = 0b0000000, test = [0100,11000,0000000](low bit -> high bit)
   
       i = *((short *)&test); //test = 0b0000,0000,0011,0010 = 50
       printf("%d\n", i);
   }
   ```
13. 关于涉及`static`的一些作用域问题：
   ```c
   #include <stdio.h>
   #include <string.h>
   static int a = 1; //static 定义一个静态全局变量，作用域仅为当前文件
   void fun1(void) { a = 2; } //修改静态全局变量a
   void fun2(void) { int a = 3; } //声明一个作用域为当前函数体内的局部变量a
   void fun3(void) { static int a = 4; } //声明一个作用域为当前函数体的静态局部变量a，其生命周期被延长
   int main() {
      printf("%d", a); //打印静态全局变量，a = 1
      fun1(); //修改了静态全局变量，a = 2
      printf("%d", a); //打印静态全局变量，a = 2
      fun2(); //声明的局部变量在函数结束后被销毁
      printf("%d", a); //打印静态全局变量，a = 2
      fun3( ); //声明的局部变量在函数结束后未被销毁，但仅作用于fun3函数
      printf("%d", a); //打印静态全局变量，a = 2
}
   ```
14. 阅读以下代码：此段代码的功能是计算字符串中出现的连续的数的和，而不是拼接字符串中的数字。
```c
   for (int i = 0; str[i] != '\0'; i ++ ) {
      t = 0;
      while(str[i] >= '0' && str[i] <= '9') { //while循环找到一个连续的数
         t = t * 10 + str[i] - '0';
         i++;
      }
      s = s + t; //累加
   }
```
15. 给出以下定义，下列哪些操作是合法的？**请注意第三条！**
```c
   const char *p1 ="hello";
   char *const p2 = "world";
   //下列哪些操作是合法的？
   p1++;        //合法，p1指向的是字符串首字母的常量指针，指针的值（指向）可以改变。
   p1[2] = ‘w’; //非法，p1是常量指针，不可修改常量指针指向的值。
   p2[2] = ‘l’; //非法，尽管p2是一个指针常量，修改指针常量指向的值是合理的，但此处"hello"是一个字面字符串常量，存储于文字常量区，不可修改！
   p2++;        //非法，p2是指针常量，不可修改指针的值（指向）。
```
