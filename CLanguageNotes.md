# C
> 请从收藏夹中嵌套定义之后开始看

## 说在前面
刷题中C和C++的题混合在一起，下文的知识点也是杂糅的，请注意！C++已标注出。

## I Grammar 
1. `struct`存在字节对齐。
2. C允许赋值使用连等，声明不允许连等。即`int a = b = 1;`是错的，但是`a = b = 1;`是对的。
3. 格式输出：  
   - string的格式化输出：`%m.ns`表示长度为n~m的字符串。
   - data格式化输出：`%md`以宽度m右对齐输出data，宽度小于实际时，按实际输出，不足补空格；`%0md`补0，其他同前者；
   - float的格式化输出：`%m.nf`以宽度m输出保留n位小数，宽度小于实际时，整数部分按实际输出，但小数需要四舍五入至n位。
      > 例如123.456按`%1.1f`输出的结果是123.5
4. **二维数组的指针：对于`int a[5][5];`**
   - **`a`是指针，值为二维数组的起始地址，`*a`对`a`解引用得到第一行的起始地址，他们指向的地址相同，但指向的值不同（一个是二维数组，一个是一维数组）；**
   - **`a[0]`是指针，值为第一行的起始地址，解引用指向它的指针的写法为`*a`，另外`a[0]`与`*a`是等价的；**
   - **`a[0][0]`是值，为第一个元素的值，解引用指向它的指针的写法为`**a`或`*a[0]`。**
   - **数组的指针退化：**
     - **名称为一维数组名的指针，退化成指向元素（仅向下一维）的指针，对其做加一操作将偏移一个元素的距离而非数组长度的距离，但是取址后加一偏移数组长度的距离，见题2；**
     - **该指针为常量指针，不可赋值，自增是不合法的；**
     - **当函数参数声明使用数组时依然会存在指针退化，例如`int fun(int* p[4])`等价为`int fun(int** p)`。**
   - **可以用取址代替解引用，例如`a[1][2] == *(*(a + 1) + 2) == *(&a[1][1] + 1) == *(a[1] + 2)`。**
5. `extern "C"`修饰的函数会被编译器强制按照C语言的方式进行编译。
6. 顺序求值运算符`,`，逗号表达式的值等于最后一个表达式的结果，且赋值运算符优先级大于顺序求值运算符。
7. 关于ASCII与ANSI：ASCII是ANSI的子集。
   - 标准的ASCII占7bit，扩展的ASCII占8bit；
   - ASCII含有关于控制的字符，不可打印。
8. 字符常量：普通字符`'A'`与转义字符`'\101'`或`'\0101'`或`'\x41'`，转义字符只能用八进制或十六进制。特别的，反斜杠的转义字符为`\\`。
9. **C语言不支持运算符重载**。C++支持重载，但三目运算符`?:`、作用域运算符`::`、成员指针运算符`.*`与`->*`、`.`、`sizeof`不可重载。
10. 结构体中不允许直接定义本结构体类型的变量，但可以定义指向本结构体类型的指针。
11. 从C源代码到可执行文件的四个过程：预处理、编译、汇编、链接：Linux下每个过程对应的生成文件扩展名为：.c -> .i -> .s -> .o -> .exe
12. C的函数省略类型默认为int，且与返回类型不一致时，均以函数类型为准。
13. **`static`关键字的作用**：
    - 静态局部变量：仅初始化一次，即使无值也会默认填0；另外改变变量的存储位置（栈区->静态区），延长生命周期；
    - 静态全局变量：仅当前文件可访问，外部文件即便使用`extern`也无法访问；
    - 静态函数：仅当前文件可访问；
    - 静态成员变量与成员函数：可以通过对象或者类名访问静态成员函数；
    - “出现在类体外的函数定义不能指定关键字`static`”：在外部定义成员函数时不能使用`static`，因为成员函数作用域为类域，在外使用`static`会改变为文件域，从而报错。
14. 函数原型： `returntype funcname(paratype paraname);`，其中返回类型和参数名可省略。
15. 指针声明后未初始化，其值是随机的，也是野指针。除此以外，指针越界访问与指针指向的空间被释放，也会导致野指针。
16. 三目运算符结合性从右到左。
17. 文件读写模式：
    - r读文件，w清空写，a追加写，+表示扩充；
    - b表示二进制文件，t表示text；
    - r和r+文件必须存在，否则返回打开失败；
    - w和w+在文件存在时清空文件再写；
    - a和a+再文件末尾追加写。
18. 赋值与复合赋值的区别：
    - 从计算机来看是等效的；
    - 从内存看复合赋值不会使用临时变量，而是直接将结果赋值，赋值语句将右边算术结果存于临时变量，再赋值给左边。
19. 对于指针变量p，`p = NULL;`等价于`p = 0;`。
20. 装入时静态分配内存，运行时动态分配内存。
21. 指针可以进行比较大小、赋值、减法，但不能进行加法。减法运算的意义是丘两个地址的距离，而加法是没有意义的。
22. C语言程序能够在不同的操作系统下运行，这说明C语言具有很好的移植性。（硬件兼容，软件移植）
23. '\0'的值为0，在内存中的存储值为00000000，它是ASCII的第一个字符（控制字符）。
24. C语言中数据类型长度：
    - `32bit: bool/char/uchar 1B, short int 2B, double/ll 8B, else(include **pointer**) 4B`
    - `64bit: bool/char/uchar 1B, short int 2B, long/ulong/double/ll/**pointer** 8B, else 4B`
25. IEEE754标准下float浮点类型的格式: 1bit符号位，8bit阶码位，23bit尾数位。阶码真值取值范围为-126~127，即阶码数值-偏置值127。
26. for循环和while循环一样，一旦判断为否就会结束。
27. 以下运算符的优先级大于乘、除、模：`-负号, ~按位取反, ++自增, --自减, *取值, &取址, !逻辑非, (typename)强制类型转换, sizeof()长度运算符`。
28. 在C语言中，函数的定义不可嵌套。
29. heap的push和pop操作：
    - push：将元素插入堆尾，然后自底向上调整；
    - pop：将堆首（根）删除，再将堆尾替换堆手，然后自顶向下调整。
30. 建堆：
    - 若对完整序列直接建堆：先按层次遍历构建完全树，再调整为堆；
    - 若依次插入数据，则每次插入后都需要调整为堆。
31. 值类型和引用类型的空间：
32. 堆的
33. 标识符、预定义标识符以及关键字：。
    - 标识符：非数字开始的一个由字母、数字、下划线组成的字符串；
    - 预定义标识符：系统预先定义的标识符，如系统函数名，系统常量名；
    - 关键字：具有特殊含义的词语，共32个，均为小写字母。
34. 无法通过内存释放函数free(void*)直接将某块已经使用完的物理内存直接还给操作系统，因为可能要等到进程结束才能释放。
35. **C语言进程的逻辑地址分区：**
    - 栈区：存放函数形参、返回值以及局部变量，包括指针；
    - 堆区：此区域需要程序员手动释放，否则可能由OS在程序结束时释放；
    - 全局（静态）区：包括全局变量、静态（全局/局部）变量，已初始化存放于`.data`，未初始化存放于`.bass(Block Started by Symbol)`；
    - 文字常量区`.rodata`：例如"abc"；
    - 代码区`.text`
36. **可执行程序的三段：**
    - `.bss`：未初始化；
    - `.data`：已初始化以及常量；
    - `.text`：代码。
## II Function&System Call
1. fseek函数：`int fseek( FILE *stream, long offset, int origin );`，功能为移动到文件的某一个位置。
   > 三个参数分别为，文件指针，位移量，起始点。
2. strlen函数：`strlen()`的参数必须是`const char *`，其计算长度的方法是，计算开始至第一个终止符`'\0'`的距离（不含`'\0'`），若没有则结果未知。
   > `sizeof()`是运算符，返回所占内存字节数，因此用`sizeof()`计算C风格字符串时，结果会多计算一个终止符。
3. ftell函数：`long ftell(FILE *stream);`，得到文件位置指针当前位置相对于文件首的偏移字节数。
4. rewind函数：`void rewind(FILE *filepointer);`，使位置指针重新返回文件的开头。
5. write函数：`ssize_t write(int handle, void *buf, int nbyte);`，能够把指定长度的字节序列从缓冲区插入到输出流中。
6. 文件读写：
   - `fgetc`：读一个字符。成功返回该字符的`unsigned char`强制转换为`int`的结果，失败返回`EOF`。
   - `fgets`：读出字符串。成功返回指针，失败返回`NULL`。
   - `fputc`：写一个字符。成功返回写入的字符，失败返回`EOF`。
   - `fputs`：写入字符串。成功返回非负值，失败返回`EOF`。

## III Questions
1. 输出结果为`-1`。
  字符型占一字节在赋值0xFFFF时会截断，此时x的值为FF即11111111。
  内存中的数据是带符号补码表示，其原码为10000001，即-1。
  在printf一行，x--先输出再减一。
  ```c
  int main() { 
    char x = 0xFFFF;
    printf("%d\n",x--);
  }
  ```
2. 输出结果为`2， 5`。
  `&a`为数组a的首地址，且数组大小为5int，因此+1时的偏移量为5int，即`&a + 1`表示整个数组之后的下一地址，亦即数组结尾的下一地址。
  而`a + 1`的偏移量为1int，a + 1表示下一个数组元素的地址。
  此题中进行了强制转换`(int*)(&a + 1)`，因此`ptr - 1`的偏移量为1int，因此`ptr - 1`为数组的最后一个元素地址。
  `*(a + 1)`显然为数组的第二个元素。
  ```c
  int main() {
      int a[5]  = {1, 2, 3, 4, 5};
      int *ptr = (int*)(&a + 1);
      printf("%d, %d", *(a + 1), *(ptr - 1));
      return 0;
  }
  ```
3. C++运算符重载：由于C不涉及运算符重载，这里只引用网址。
   - `https://www.nowcoder.com/questionTerminal/be52cbd020be462f8f5a5a1e8b63aca7?`
   - `https://www.nowcoder.com/questionTerminal/aa0807a3e1e641e0b71ce62c08c5e205?`
4. 输入`ABC`，输出结果为`ABC6789`。
     - `gets()`会将输入流中的回车`'\n'`转换为`'\0'`存入`ss`中，此后`ss = 'ABC\0,3,4,5\0'`；
     - `strcat()`会从第一个`'\0'`开始拼接两个字符串，此后`ss = 'ABC6789\0,5\0'`；
     - 输出时读取到第一个`'\0'`就会停止。
   ```C
   #include  “stdio.h"  
   #include  “string.h"  
   int main()  
   {  
       char ss[10]="1,2,3,4,5";
       gets (ss); 
       strcat (ss,"6789"); 
       printf ("%s\n",ss); 
       return 0;
   }
   ```
5. 辨析：
   ```C
   int *p[n];//指针数组
   int (*)p[n];//非法，括号内的*没有关联变量或类型名
   int *p()；//指针函数
   int (*)p();//非法，括号内的*没有关联变量或类型名
   //另外，函数指针的正确写法如下：
   int (*p)();//p指向一个返回类型为int，不接受任何类型的参数。
   ```
6. **关于`fork()`**，`fork()`不是C的库函数，是Linux系统调用。
   该段代码将生成3个子进程，输出6次。
   ```
   P0->P1->P3
     ->P2
   ```
   ```C
   #include <unistd.h>
   #include <stdio.h>
   int main(void) {
       int i = 0;
       for(i = 0; i < 2; i++){
           pid_t fpid = fork();
           if(fpid == 0)
               printf("hello world!\n");
           else
               printf("hello world!\n");
       }
       return 0;
   }
   ```
7. 以下代码存在的问题。
   ```C
   <pre>
      void func1(char *e){
         char *p1;
         p1=malloc(100);//C中可以不用强制类型转换，但其申请的空间在后面没有被释放
         sprintf(p1,error:"%s'.",e);//gpt说此处可能溢出
         local_log(p1);
      }
   </pre>
   <pre>
      int func2(char *filename){
         FILE *fp;
         int key;
         fp=fopen(filename,"r");//打开流在后面未关闭
         fscanf(fp,"%d",&key);
         return key;
      }
   </pre>
   <pre>
      void func3(char *info){
         char *p,*pp;
         p=malloc(100);
         pp=p;
         free(p);
         sprintf(pp,*info:"%s'.",info);
         free(pp);//pp和p所指的空间是一样的，这里free了同一块空间
      }
   </pre>
   ```
8. 以下函数中，和其他函数不属于一类的是fseek。`{ read, pread, write, pwrite, fseek, lseek}` 。只有fseek是库函数，其他都是系统调用
9. “函数中的静态变量,在函数退出后不被释放”，这句话不完全正确，主函数作为程序的入口在退出后会释放静态变量。
10. 如下函数存在的问题：由于值传递，实际上申请到空间的是形参p，而不是实际的p指针，实际的p指针依然为NULL。
    > 如果在C++中可以使用引用传递，即`char* &p`
    ```c
    void getMemory(char *p) {   // (char **p)
       p = (char *)malloc(100); // *p = (char *)malloc(100);
    }
    ```
