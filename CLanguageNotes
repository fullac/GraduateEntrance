# C
## 错误
1. `struct`存在字节对齐。
2. C允许赋值使用连等，声明不允许连等。即`int a = b = 1;`是错的，但是`a = b = 1;`是对的。
3. string的格式化输出：`%m.ns`表示长度为n~m的字符串。
4. fseek函数：`int fseek( FILE *stream, long offset, int origin );`，三个参数分别为，文件指针，位移量，起始点。功能为移动到文件的某一个位置。
5. `extern "C"`修饰的函数会被编译器强制按照C语言的方式进行编译。

## 原题

1. 输出结果为`-1`。
  字符型占一字节在赋值0xFFFF时会截断，此时x的值为FF即11111111。
  内存中的数据是带符号补码表示，其原码为10000001，即-1。
  在printf一行，x--先输出再减一。
  ```c
  int main() { 
    char x = 0xFFFF;
    printf("%d\n",x--);
  }
  ```
2. 输出结果为`2， 5`。
  `&a`为数组a的首地址，且数组大小为5int，因此+1时的偏移量为5int，即`&a + 1`表示整个数组之后的下一地址，亦即数组结尾的下一地址。
  而`a + 1`的偏移量为1int，a + 1表示下一个数组元素的地址。
  此题中进行了强制转换`(int*)(&a + 1)`，因此`ptr - 1`的偏移量为1int，因此`ptr - 1`为数组的最后一个元素地址。
  `*(a + 1)`显然为数组的第二个元素。
  ```c
  int main() {
      int a[5]  = {1, 2, 3, 4, 5};
      int *ptr = (int*)(&a + 1);
      printf("%d, %d", *(a + 1), *(ptr - 1));
      return 0;
  }
  ```
